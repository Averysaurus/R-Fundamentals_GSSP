---
title: 'R Fundamentals Part 3: If statements, for loops and functions'
author: "Samy Abdel-Ghaffar"
date: "August 15, 2017"
output:
  html_document:
    toc: yes
    toc_float: yes
---

Contributions by: Guadalupe Tuñón, Dillon Niederhut, Shinhye Choi, Rochelle Terman, Evan Muzzall

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Part 3 Learning objectives
1. Introduction to Control Statements
2. If Statements
3. For loops
4. Functions

Load your `emotions.csv` file from Part 2 if it's not already in your global environment:
```{r}
emotions_df <- read.csv('data/emotions.csv', header=TRUE, stringsAsFactors = FALSE)
```

# 1.  Introduction to Control Statements

There are many scenarios where we want to run some code only under certain circumstances, or run the same code over and over. **Control Statements** are functions in R that let us control how our script will execute in a way that is more complicated than just one line after the next. Some examples are:
1. Oftentimes in research scripts are resused for various similar, but slightly different tasks. It is common to use logical variables to turn on or off different parts of the script that may be doing different preprocessing steps on some data, for example. `if` statements are used in these cases to only run the specified preprocessing step when the logical variable (called a **Flag** in the scenario) is `TRUE`.
2. Imagine you have a categorical variable in a dataframe, and you want to do some calculations with other variables, based on the value of this categorical variable. You could use a `for` loop to look at each observation you have, and then nested `if` `else` statements to handle each level of the categorical variable differently.
3. There is a calculation you do all the time (for example you threshold some data at 0 and then scale it). Instead of writing that code over and over again, you can put it into a `function` so that it is simple to use.

# 2. If Statements

## 2.1 Simple If Statements

`if` statements are control statements that let you control whether or not block of code is executed or not. They consist of a **condition** (which is either a logical variable, or a logical test), and a **statment** (block of code) that is executed only when the **condition** is `TRUE`. Here's the synatax:

`if (condition) {statement}`
```{r, eval=FALSE}
?"if"
```
```{r}
if (nrow(emotions_df) > 1000){
  print("Wow, we've got some big data!")
}
```

As an example, let's say we read in a csv file containing a 2D dataset and want to remove any missing data before we do our analysis. We might want to know that we removed some data, and how much, so we can note that in our methods section of our paper. This is how we would do that:
```{r}
# Use the complete.cases function and which functions we learned today to get the row numbers that have at least one piece of # missing data NA
missingrows <- which(!complete.cases(emotions_df))

# now let's write out a file that lists the row numbers of
if (length(missingrows) > 0){
  write.csv(missingrows, "data/RowNumbersWithMissingData.csv", col.names = FALSE)
}
```

### Challenge
1. Write an `if` statement that determines if the number of Republican voters is greater than the number of Democratic voters, and prints how you feel about that!

## 2.2 If/Else statements
Sometimes it's useful to do two different things when our **condition** is either `TRUE` or `FALSE`. In these scenarious we use the `if` and the `else` statements
```{r}
SCALE_DATA <- TRUE
if(SCALE_DATA) {
  valence_foranalysis_df <- scale(emotions_df$Valence)
} else {
  valence_foranalysis_df <- emotions_df$Valence
}

# Now run my statistical tests on the new dataframe, and we don't have to worry if it was scaled or not...
```
In this example I defined a **Flag** (which many people use all capitals for, just by convention) that indicates whether I want to scale (or Z-Score) my data. I used an `if` `else` statement so that whether or not I scaled my data, I could have a single variable that I would use for later analyses, and not have to worry about which version of the variable I should use. This is especially useful if you have a preprocessing script with many different steps!

The `ifelse` is a shorthand way to have in if else statement for simple **statements** (or blocks of code). It is very handy to recode data from one convention to another, or to make a new dataframe variable that is a summary of another, as long as you have two conditions that are binary/mutually exclusive. 

syntax: `ifelse(test, yes, no)`

Imagine I want to create a new variable in the emotionds dataframe indicating whether the subjects' `Anxiety` score is low or high (above or below the `median()` of all the data. I can do this easily with the `ifelse()` function:
```{r, eval=FALSE}
?"ifelse"
```
```{r}
emotions_df$AnxietyHighLow <- ifelse(emotions_df$Anxiety>=median(emotions_df$Anxiety), TRUE, FALSE)
sum(emotions_df$AnxietyHighLow)
```
**NOTE** Since logicals are stored as 1s and 0s, we can sum vectors of them. The result is the number of values that are `TRUE` within that vector of logicals.

### Challenge
1. Create a **flag** and use that flag as the **condition** to an  an `if` `else` statement to determine whether to create a subset of all the Democratic or Republican voters. Call this the political_party_df.
2. Let's be mishevious and create some potential voter fraud! Use the `ifelse` function to replace the `Age` in the `political_party_df` you just created with the value 17 for all voters living in `CA`.

## 2.3 Nested If/Else Statements

If you want to do something based on more than a single yes/no condition you can use multiple (or nested) `if` `else` statements. Here's an example doing something different for the 3 levels of `Gender` in the emotions dataframe:
```{R}
indexToActOn <- 10
if(emotions_df$Gender[indexToActOn] == 'Female'){
  print( 'We found a female person.')
} else if(emotions_df$Gender[indexToActOn] == 'Male'){
  print( 'We found a male person.')
} else if(emotions_df$Gender[indexToActOn] == 'Other'){
  print( 'We found an other gendered person.')
} else {
  print( "Uh-Oh, we encountered a Gender factor level we weren't expecting")
}

```

### Challenge
1. Fill in the nested `if` `else` structure that prints the state slogan (make it up or look on wikipedia) where a random voter lives. Use the index variable `voterIndex` to determine which voter to check.
```{r, eval=FALSE}
voterIndex <- 100 # you can change this number
# TODO - Fill in the code below
if(){
  print('SLOGAN #1')
} else if(){
  print('SLOGAN #2')
} else if(){
  print('SLOGAN #3')
} else if(){
  print('SLOGAN #4')
} else if(){
  print('SLOGAN #5')
}
```

# 3. For loops

## 3.1 For Loop Structure
A `for` loop repeats a block of code a certain number of times until a certain condition is met (or is no longer satisfied). A for loop has 3 parts to it: 
syntax: `for (variable in sequence) {statement}`
1. **Variable**: This variable gets assigned each value from the **sequence** in order. It is usually used within the *statement* (code block) as an index into some vector, matrix or dataframe. You can give this any name you want, but be careful not to overwrite a variable you've already created (use a new name)!
2. **Sequence**: A vector containing the numbers that will be assigned to the **variable**. Usually it is a sequence from 1 to the number of times you want to loop, but it doesn't have to be.
3. **Statement**: A block of code that you want to execute over and over again. Usually this code is doing something with values from a vector, matrix or dataframe.

All for loops are precluded by `for` so that R knows you want to iterate over a loop. Here's a simple example:
```{r, eval=FALSE}
?"for"
```
```{r}
# simple example to print out the 1st through 10th Valence values.
for (i in 1:10){
  print(emotions_df$Valence[i])
}
```

Usually we don't know exactly how many times we want to loop when we write the code because it depends on the size of the data we are dealing with. In this case we can use a variable to define how many times to loop. Let's loop over all the rows in the emotions dataset by using the `nrow()` function to define the length of our **sequence** in the for loop.
```{r}
for (i in 1:nrow(emotions_df)){
  print(emotions_df$Valence[i])
}
```

Although we usually want to loop over a sequence of indices into some dataframe, we don't have to. We could iterate over a vector of characters if we wanted to:
```{r}
charsToIterate <- c('Loops', 'Are', 'Very', 'Versatile')
for (curChar in charsToIterate){
  print(curChar)
}
```

### Challenge
1. Write a `for` loop that will iterate over all the rows in the `election` data, and print the `State` of the voter in row 1000.

##  3.2 Example Loop with If/Else

Let's create some code combining loops with `if` statements. Let's imagine we found a bug in our code that ran the experiment. Oh No! For Scenarios `S1`, `S2` and `S3` we switched the `Valence` and `Arousal`. Let's fix it!
```{r}
for (curTrial in 1:nrow(emotions_df)){
  if(emotions_df$Scenario[curTrial] %in% c('S1', 'S2', 'S3')) {
    tempValence <- emotions_df$Valence[curTrial]
    emotions_df$Valence[curTrial] <- emotions_df$Arousal[curTrial]
    emotions_df$Arousal[curTrial] <- tempValence
  }
}
```
I used a new operator there, `%in%`. This is a logical test that return true if the value before it exists in the vector after it. So here, I used subsetting to get the `Scenario` for the current trial, and I want to see if that is any one of 'S1', 'S2', 'S3'. If it is, this test will be TRUE, and the code will execute the 3 lines within the `if` statement, otherwise it won't do anything and continue on to the next trial.

How many **iterations** did the loop do? In other words, how many time did it execute that **statement** (block of code)?

## 3.3  Getting out early - `break`

For long loops with complicated rules for when to stop, many intermediate commands can help us "end the looping" once a condition is met, or when a condition is no longer satisfied. We use `break` to tell R it should stop the loop early, before it has gone through all the items in it's **Sequence**.

`break` ends the looping once a certain condition is met.
```{r, eval=FALSE}
?break
```

`if` statements are frequently used along with `break` to first check for a spefic condition before breaking out of the loop. Here we want to keep printing until we find a large valene value, and then stop the code:

```{r}
for(i in 1:nrow(emotions_df)){
    print(emotions_df$Valence[i])
    if(emotions_df$Valence[i] > 10){
      break
    }
}
```

Let's quickly add one `NA` value to the `Valence` in position 15: 
```{r}
emotions_df$Valence[15] <-  as.numeric(NA)
```

And now we'll loop again, but this time we tell the code to stop if `Valence` reaches a missing value (`NA`):
```{r}
for(i in 1:nrow(emotions_df)){
    print(emotions_df$Valence[i])
    if(is.na(emotions_df$Valence[i])){
      break
    }
}
```

### Challenge
1. Find all the unqiue **levels** (hint: remember the `unique()` function) that the `State` dataframe variable in the election data can take. 
2. Iterate (loop) over all the **levels** of `State` and calculate the average (mean) `Age` for all the voters in each `State`. If the average age is more than 30, then print out the name of that state.

# 4.  Functions
A function is a set of commands (or recipe or algorthm) that accomplishes a single task and/or is to be used repeatedly. For example, if you want to run the same satatistical tests on several datasets, you might want to write a function that contains instructions for all the tests once, so that you do not have to rewrite the code each time. We've already used functions extensively throughout this workshop, but now we'll see how to **define**, or create, our own.

## 4.1 Defining a Function
Every function definition has four parts and its basic syntax looks like this:  

> function.name <- function(x){
>   body of function
> }

1. `function.name` - like variables in R, it is helpful if you give your function a relevant name.
2. `function(x)` - `function` lets R know you are writing a function and `(x)` contains the inputs/arguments.
3. `{body of function}` - the body of the function is contained within curly braces { } and comprises the statements that you want R to evaluate.
4. The `environment` Every function has it's own environment (just like scripts operate on the global environment) that contains all the variables that the function creates. R does this so that the variables in functions don't "contaminate" the global environment. 

For example:
```{r, eval=FALSE}
?"function"
```
```{r}
test_function <- function(x){
  x + 1
}

class(test_function)        # Returns the class of `test_function`
formals(test_function)      # Shows the defined arguments
body(test_function)         # Displays the statements to be evaluated
environment(test_function)  # Returns the envirnoment his function is defined in. NOT the function's own local environment
test_function               # Shows all the above information about your function 
```

See how our function has `R_GlobalEnv` as it's environment? That's because we defined it in the global environment. This means that if you tell a function to look for an `variable`, it will look in the global namespace - not within the function itself.

We evaluate functions that we define in the same way as functions R defines, by calling the name of the function with your argument `x`  within parantheses. R then evaluates the body of the function and returns the desired output for the specified input. 

If we want to see what `test_function` returns when the argument (`x`) = 2, we type:
```{r}
test_function(2)
```

### Challenge
1. Define a function with a single argument that determines the length of that argument, and either returns the argument itself if it only has 1 **element** (or item), and the median if it has more than 1 **element**.
2. Call this function with a numeric, integer, character and logical vector.

## 4.2 Default Arguments
We can also add a predetermined value for one or more arguments, which serves as a default value that will be assigned to that argument when the function is called without the argument. To do this add a `=` after the argument and then the default value. By convenction, required arguments do not have default values and are listed before optional (default) arguments in the function definition.

Let's add a new argument called 'y' and give it a default value. 
```{r}
funcWithDefault <- function(x, y=2){
  (x + y) / y
}
funcWithDefault(5)
funcWithDefault(4, 4) # here, we do not need to specify `x` and `y` because R knows that the second argument is "y"
funcWithDefault(4, y=4) # this is the same as f(4, 4)

#does f(y=4, 4) work? Yes, but it is not recommended.
funcWithDefault(y=4, 4)
```

Sometimes it's useful to have the default value be empty (`NULL`) to indicate that no argument was passed in, and nothing should be done with it
```{r}
funcWithNULLDefault <- function(x, y=NULL){
  if (is.null(y)){
    returnValue <- x
  } else {
    returnValue <- (x + y) / y
  }
  returnValue
}
funcWithNULLDefault(5)
funcWithNULLDefault(5,10)
```
### Challenge
1. Define a function that has 3 arguments, two of which are optional (have default values). Make the optional arguments default to `NA`. First check whether any of the arguments are `NA`, and then take the mean of only the values that are NOT `NA`.

## 4.3 Return Values

As we learned earlier all functions return something, although sometimes it is something useless such as a NULL value. By default R will return the value from the last line in a function, as we've seen in the example function definitions above. It is good practice to be explicit however, and use the `return()` function, so nothing unexpected happens.

Let's update the test function we created above:
```{r}
test_function <- function(x){
  return(x + 1)
}
```

Imagine you want your function to just return x if y is not passed in, as in the `funcWithNULLDefault` above. It is even more important that you use the `return()` function inside the `if` statement because you may decide later on to do more after the `if` statement which could totally change the value returned. For example
```{r}
funcWithNULLDefault <- function(x, y=NULL){
  if (is.null(y)){
    return(x)
  } 
  
  # this is the return value as the code is written
  (x + y) / y
  
  # but if new code is added here later on, and return wasn't called above, the function wouldn't return x when y is NULL 
}
```

Although you can only pass a single argument to `return()`, if you need to return multiple items you can use a `list()`:
```{r}
funcMultiReturn <- function(x, y){
  return(list(x+5, !y))
}  
```

### Challenge
1. Define a function that takes two arguments, assume the first is dataframe and the second a character vector. Use the character vector to subset the columns of the dataframe. Then return 3 things: the average of those columns, the minimum value of those columns and the maximum value of those columns. (Hint: `min()` and `max()` find the minimum and maximum values of a vector, respectively)

## 4.4 Environment in Functions

Every time a function is **called** (NOT just defined), it has it's own **environment**. This means all the variables created in a function are only available within the function.

Let's try one more example where we define object `z` within the function. 
```{r}
environmentTest <- function(x){
  z <- 5
  return(x + z)
}

environmentTest(10)

# Does the variable 'z' exist in the global environment?
zInGlobal <- 'z' %in% ls()
```
Now we ask: does `z` appear in your global environment? Why not? `z` is protected from what is happening outside the function!  

Conversely, any function has access to all the variables stored in the global environment. Now let's define `z` in the global environment and see if the function can access it:
```{r}
z <- 5 # define z outside of the function environment in the global environment

environmentTest2 <- function(x){
  return(x + z)
}
environmentTest2(10)

zInGlobal <- 'z' %in% ls()
```
`z` is now defined in the global environment and the function can acess variables from the global namespace.

> **NOTE** It is a REALLY BAD IDEA to use write a function that relies on variables existing in the global environment. Why? Because the function has no control over whether that function is created or not, and so if you use the function and forget to define that variable first, the function will fail with an error. In general it is good practice to make functions "self-seficient", meaning able to run in any environment.

### Challenge
1. Define a function that contains **local** variables. Get creative here and do something with the election data to end up with a useful, new dataframe. Try to use everything we've learned so far, including: `if` statements, `for` loops, subsetting, type coercsion. Then write this new dataframe to a csv file.

## 4.5 Example - unit conversion example
Unit conversion is a common obstacle in research. Let us write a function that converts inches to centimeters. For now however, pretend that we think that one inch is equal to 2.5 centimeters - we will show you how to update it below. 

Define a function called `in_to_cm` and then enter Evan's height (74 inches):
```{r}
in_to_cm <- function(x){
  x * 2.5
}
in_to_cm(74)
#Evan is 185 cm tall (incorrectly assuming that 1 inch = 2.5 cm)
```
What if we want to know how tall I am in meters?

You could type:
```{r, eval=FALSE}
in_to_m <- function(x){
  x * 2.5 / 100
}
```
...but this would be repeating yourself!

Then, when you figure out that the conversion factor is really *2.54*, not 2.5, you might update one function and forget to update the other - these inconsistencies can cause problems.

Instead, let's define a new function called `in_to_m` so that the output of `in_to_cm` is used in the new function! 
```{r}
in_to_m <- function(x){
  in_to_cm(x) / 100
}
in_to_m(74)
```
Now, if we go back and update `in_to_cm`, those changes automatically get propogated to `in_to_m` and we do not have to worry about updating it: 
```{r}
in_to_cm <- function(x){
  x * 2.54
}
in_to_m(74)
#Evan is actually 1.8796 meters tall
```

## 4.6 Advanced Example - Reading in some text files (Optional)

One way in which R is more powerful than many statistics programs is that it lets you do complex calculations on your data via subsetting and `for` loops. Let's imagine that we want to read in a supplementary file for all of our subjects that have an **Other** gender specification because it contains more information on their gender identity that we collected after the original experiment. We could do this with a loop:
```{r, eval=FALSE}
# get the SubjectNo of all subjects that identify as 'Other' gender
otherGenderSubjectNos <- unique(emotions_df[emotions_df$Gender == 'Other', 'SubjectNo'])

# let's add a new variable to our dataframe for special notes
emotions_df$Notes <- character(nrow(emotions_df))

# loop over those subject numbers and read their file containing more information
for (curSubjectNo in otherGenderSubjectNos) {
  # create the filename for the current subject
  textFilename <- sprintf('TextFilename_SubjectNo%03i.txt', curSubjectNo)
  
  # read in the text file with the note
  currentNote <- readLines(textFilename)
  
  # store the current note in all the Note rows where the SubjectNo equals the current subjectNo
  emotions_df$Notes[emotions_df$SubjectNo==curSubjectNo] <- currentNote
}
```
There's a lot going on in there! Let's break it down. That first line uses subsetting (logical indexing in this case), to find all the rows where `Gender` is **Other**. It then asks for just the `SubjectNo` dataframe variable (or column). Since the SubjectNo is repeated in this dataframe for every `Trial` (each subject does 100 trials), there will be many duplicates of the `SubjectNo` in that vector. I use the `unique()` function, which removes all duplicate values from a vector, leaving one 1 copy of each of the unique values.
```{r}
uniqueTest <- unique(c(1,1,1,2,2,2))
uniqueTest

otherGenderSubjectNos <- unique(emotions_df[emotions_df$Gender == 'Other', 'SubjectNo'])
```

We then add a new dataframe variable, called `Note`, by creating a character vector that is the same length as the dataframe and using the `$` notation. The `$` followed by a new variable name will create that new dataframe variable, and in this case we store a character vector in this new dataframe variable.
```{r, eval=FALSE}
emotions_df$Notes <- character(nrow(emotions_df))
```
Finally we have our loop, where we are **iterating** over all the Subjects with `Other` gender identities (as stored in `otherGenderSubjectNos`). 
```{r, eval=FALSE}
for (curSubjectNo in otherGenderSubjectNos) {
}
```
So for each of these subjects, we create the text filename and read in the text from that file. To create the filename, we used the `sprintf()` function that we learned about in day 1. We use that to insert the cuurrent SubjectNo into the filename. Then the `readLines()` function reads all the text in from that file.
```{r, eval=FALSE}
  # create the filename for the current subject
  textFilename <- sprintf('TextFilename_SubjectNo%03i.txt', curSubjectNo)
  
  # read in the text file with the note
  currentNote <- readLines(textFilename)
```

Finally, we use subsetting to store the note text into all the rows for the current subject. Note that we're using logical indexing along with the `$`. We could also have done this using 2D logical indexing, as I show just below the original line:
```{r, eval=FALSE}
  emotions_df$Notes[emotions_df$SubjectNo==curSubjectNo] <- currentNote

  # Doing the same thing using 2D indexing instead of the $
  emotions_df[emotions_df[,'SubjectNo']==curSubjectNo, 'Notes'] <- currentNote
```

# Acknowledgements
[Software Carpentry](https://swcarpentry.github.io/)  
[Hadley Wickham](http://adv-r.had.co.nz/)  
[more Hadley Wickham](http://r-pkgs.had.co.nz/)
