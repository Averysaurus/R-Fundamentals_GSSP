---
title: 'R Fundamentals Part 1: Introduction'
author: "D-Lab"
date: "September 26, 2018"
output:
  word_document:
    toc: yes
  html_document: 
    number_sections: yes
    toc: yes
    toc_float: yes
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Workshop goals

Part 1) Introduction to R, data types, data structures (emphasis on data frame)  
Part 2) Importing, subsetting, and merging data; type coercion, identifying missing data  
Part 3) Research design, data exploration, and statistical testing  
Part 4) Mini-projects

**Bonus**  
- What is RMarkdown? Why you should consider using RMarkdown (.Rmd) instead of a plain-text script  
- For-loops and functions; Monte Carlo simulation, the "birthday problem"  

**Part 1 learning objectives:**  
1. Introduction: What is R? Navigating RStudio variables, global environment, packages, variable assignment, help  
2. Data types: numeric, integer, character, logical, and factor  
3. Data type coercion  
4. Data structures: vector, list, matrix, data frame  
5. Saving your work  
6. Swirl  

# Part 1 - Introduction

### The student

This document is designed as a resource for **the student**. Use these documents if you choose to follow along, need to review, or choose to read ahead.  

### The instructor

**The instructor** should emphasize that:  
1. R is free and open-source
2. Is great for data visualizaiton
3. Utilizes many analytical packages written for your field
4. Is ideal for open and reproducible research
5. Has strong community support and help and is used by virtually all academic disciplines, business, and industry.  

Then, the instructor will:  
6. Provide a few motivating examples for the class  
7. Describe how to apply R to research  
8. Point out some of R's shortcomings along the way    
9. Lead typing walkthoughs of these R functions  

### R and RStudio

R is a programming language based on the [S](https://en.wikipedia.org/wiki/S_(programming_language)) language and is **functional**, **object oriented**, and **interpreted**. These themes make R highly extensible. However, we do not need to think of R in such complicated terms. In this workshop, we want to provide you with basic programming competencies so you can immediately apply what you learn to your own research. In general, programming languages such as R can simply be thought of as a way to give instructions to a computer to accomplish a task. R is the actually programming language that you will learn to use.  

RStudio is the premier R graphical user interface (GUI) and integrated development environment (IDE) that makes R much easier to use. It can directly interface with [GitHub](https://en.wikipedia.org/wiki/GitHub) for sharing, collaboration, and version tracking and even makes it easy to program in other languages such as [Bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) and [Python](https://en.wikipedia.org/wiki/Python_(programming_language)). R's many additional user-defined software "packages" (add-ons that provide to you a lot of shortcutted functions) allow for relatively straightforward completion of tasks such as importing and preprocessing data, statistical testing, and producing publication-ready visualizations, especially in areas such as statistical modeling, machine learning, deep learning, natural language processing, and time-series analysis.  

### Tools --> Global Options

Before we begin, let's set a few RStudio settings to improve your experience.  

1. Click "Tools --> Global Options --> Appearance" to change your color and font settings.  

2. Click "Tools --> Global Options --> Code" and check the box that says "Soft-wrap R source files" to wrap the text in your script to the width of the script pane.  

3. Click "Tools --> Global Options --> Code --> Display" and check the boxes that say "Highlight selected line" and "Highlight R function calls". 

### The basics: Navigating RStudio

Open RStudio! Then, open a new script by clicking "File --> New File --> R Script" or by pressing `Ctrl + Shift + N` (PC) or `command + shift + N` (Mac). After opening a new script, you should see four window "panes". 

##### 1. Top left pane

Enter code in this savable `script` file. This is a plain text file but with a .R extension. Enter `2 + 2` in your script and run a line of code by pressing `command + enter` (Mac) or `Ctrl + enter` (PC).  

A hashtag `#` tells R that you do not want that particular line or block of code to be run - this is called **commenting your code**. This is handy for making notes to yourself and you can even add hashtags after lines of runable code - on the same line!  

The name of your script file is in the tab at the top of your script window - the name defaults to `Untitled1`. Be sure to save your script by clicking "File --> Save" or `command + s` (Mac) or `Ctrl + s` (PC). You can also click the floppy disk icon to save. 

##### 2. Bottom left pane

Code output is displayed here in the `console`. This space is also good for just noodling around and trying out code that you do not wish to save in your script.  

In the console, the prompt `>` looks like a greater than symbol. If your prompt begins to look like a `+` symbol by mistake, simply click in your console and press the `esc` key on your keyboard as many times as necessary to return to the prompt.  

R uses `+` when code is broken up across multiple lines and R is still expecting more code. A line of code does not usually stop until R finds an appropriate stop parameter, often a closed parenthesis `)`, closed bracket`]`, etc.  

If the output in your console gets too messy, you can clear it by pressing `control + l` on both Mac and PC. This will not erase any saved data - it will simply make your console easier to read. 

##### 3. Top right pane

In R, data are saved as "variables". Variables are simply placeholders for a value, word, function, or dataset! The global "Environment" tab displays the variables you have assigned. "Global" simply means that these variables are available for everything. 

##### 4. Bottom right pane

Here you find useful tabs for navigating your file system, displaying plots, installing packages, and viewing help pages. Press the `control` key and a number (`1-9`) on your keyboard to shortcut between these panes and tabs. 

### Package installation

Many people write clever software that makes R smarter/better/faster/stronger. You can install packages by clicking the "Packages" tab in the bottom-right window, clicking install, and then searching for the package you wish to install (or use the `install.packages()` function, but wrap the name of the package in quotation marks). It is generally good to keep RStudio and your packages up to date! Install the packages we will use in the workshop: 

```{r, eval=FALSE}
install.packages(c("ggplot2", "knitr", "psych", "rmarkdown", "reshape2", "swirl"), dependencies = TRUE)
```

### The `library` function  

However, installing a package is only the first step of the two-step process of using packages. Installing the package physically puts the files on your computer, but RStudio does not know they are there. Anytime you want to utilize a previously installed package, you must retreive it with `library()` when you begin a new R session. You do not need to reinstall packages each time you quit and restart your R session. 

```{r}
library(ggplot2)
library(knitr)
library(psych)
library(rmarkdown)
library(reshape2)
library(swirl)
# These packages can now be used in our RStudio session!
```

### Getting help  

Typing the `?` symbol before a function or dataset name can be used to bring up they help pages for that particular thing. Below are a few that we will use in this workshop series! 

```{r}
?read.csv
?class
?hist
?plot
?ggplot2::ggplot
?t.test
?lm
?summary
?psych::describe
?iris
```

### Functions and arguments
Our coding universe consists of **functions** and **arguments**.  
- Functions perform actions on things. In the natural language analogy, functions are the verbs in our sentences. An easy way to identify a function is that it contains trailing parentheses such as `mean()`. Most functions can be identified because they have trailing parentheses `()` after their names. 

- Arguments are the things; they consist of virtually anything like values, mathematical expressions, vectors, lists, matrices, words, entire books, functions, and even large datasets. These arguments go inside the parentheses of functions!

### Variable assignment

Variables are how we save things in R's memory so that they can be called (retrieved) when you need them. Assigning/defining these variables is called **variable assignment** and they are stored in your **global environment.** Traditionally, you can define objects using the **assignment operator** `<-`. This is a "less than" `<` symbol immediately followed by a hyphen `-`. You will see this symbol in many tutorials. **However, we will simply use the `=` in place of the assignment operator. This works the same but uses less keystrokes and is less confusing!**  

### Object definition/variable assignment requires three pieces of information  

1) object_name  
2) `=`  
3) definition, code to be executed

Try it! Define a variable named `number` and assign to it the number 5:
```{r}
number = 5

# The ls() function will also print what is in our global environment to the console. 
ls()
```

"Call" (retrieve) the data contained wihtin the variable by typing its name into your script and running the line of code. 

```{r}
number # 5 is returned
```

You can also use "tab completion" so that you only have to type the first few letters of your variable and press your tab key to complete it

```{r}
numb
```

Think of R as the fanciest of calculators. You can do all the maths with ease in R:

```{r}
number2 = 2
number3 = 23948723
number4 = 1239873498

number * number2 / number3 ** .5

# or 

number %*% number2 # matrix multiplication
number %% number2 # modulus division
number %/% number2 # integer division
```

### Naming R variables  

Variable names can be anything, but are always case sensitive. However, they cannot begin with a number and generally do not begin with symbols. Be consistent and give your variables brief descriptions of their contents. Names must be **unique.** If you resuse an old name, the old definition will be overwritten. Instead, you can use an underscore as a placeholder for a space to create variables names with multiple words. Let's overwrite a variable to change its definition. 

```{r}
welcome = "UC Berkeley" 
welcome

welcome = "Barrows Hall"
welcome
```

Does this make sense?
```{r}
character_data = 12
character_data
```

If we want to preserve the original variable `welcome` we have to define a new object. 

```{r}
welcome2 = "UC Berkeley"
welcome2
class(welcome2)
ls()
```

We now have multiple variables defined in our global environment! Note that `welome2` did not overwrite the variable `welcome`. 

### Removing variables

We remove individual variables from our environment with `rm()`. For example, to remove `welcome`, we type:

```{r}
rm(welcome)
ls()
welcome
```

See how `welcome` disappeared from our global environment? What happens if you try to call the `welcome` variable? What does the error message say? 

We can also wipe the entire environment with `rm(list = ls())` (or, click the broom icon in the upper right "Global Environment" pane)
```{r}
rm(list = ls()) 
ls()
```
All variables have been removed from our global environment.

# **Challenge 1**
1. What is the three-piece recipe for variable definition? What piece goes where? Why?  
2. Define five numeric variables. Write a mathematical expression that uses only these five numeric variable names (not the actual numbers).  
3. Remove one of your numeric variables. Does your expression still work? Why or why not?  
4. Wipe you global environment clean.  

```{r}
## YOUR CODE HERE
```

### Vaiable class

Everything in R has a class (or "type"). This is important because it determines what we can do to it! Variables are no exception. Use the `class` function to check a variable's type: 

##### 1. Numeric data

```{r}
number = 5
class(number)
```

Numeric data is the default data class/type for all numbers in R, even those that look like integers! "numeric" type in R is synonymous with "float" or "double". 

##### 2. Character data

Let's try another example, this time using character data. Note that character data are **always** contained within quotation marks `" "`. Single or double quotes are fine as long as you are consistent. 

```{r}
welcome = "Welcome to the D-Lab"
ls()
class(welcome)
```

"character" type is synonymous with "string" or "text" data. 

##### 3. Logical data

The logical data type consists only of `TRUE` or `FALSE`. These are stored internally as 0 and 1 and thus take on mathematical properties. 

```{r}
logical_variable = TRUE
logical_variable

logical_variable + 2
```

Logical values can also be used to test certain conditions useful for tasks such as subsetting data. You will learn more about these in Part 2.

```{r}
FALSE < TRUE # greater than
TRUE >= TRUE # less than or equal to
TRUE == TRUE # equivalent to (equal to)
TRUE == FALSE
FALSE != FALSE # not equivalent to (not equal to)

TRUE & TRUE # boolean "and"
TRUE & FALSE

TRUE | TRUE # boolean "or"
TRUE | FALSE
```

You will also find that logical values are also used to turn certain arguments on or off: 

```{r}
num_vec = c(2, 5, 8, NA, NA)
num_vec

mean(num_vec, na.rm = FALSE)

mean(num_vec, na.rm = TRUE)
(2 + 5 + 8) / 3
```

`c` concatenates a vector of data (see "Vector" section below).  

`NA` is how R recognizes missing data (see Part 2 materials).  

The `mean` function computes the arithmetic mean of a vector of numbers. 

The `na.rm` argument is currently set to `FALSE` - what should we do to instruct the mean function to remove missing data before computing the mean? (answer: set it to `TRUE` so that missing values are removed prior to computation!)

# **Challenge 2**
1. Define two numeric variables.  
2. Define two character variables.  
3. Define two logical variables.  
4. How do you check what types of data these variables are?  
5. What does the `ls()` function do? Where else do you see this information?
6. Can you perform math across these three data classes? Why or why not? 

```{r}
## YOUR CODE HERE
```

##### 4. Integer type and "type coercion"

Remember how even whole numbers default to numeric/float/double type? Turning one data type into another requires what is called "type coercion", or changing one data type to another. 

Thankfully, R has functions to perform type coercion. What happens in the code below?

```{r}
num = 23
class(num)

int = as.integer(num)
class(int)
```

# **Challenge 3**
1. Other `as.` ("as dot") functions exist as well, such as `as.numeric`, `as.character`, `as.logical`, and `as.factor`.  
2. Using your numeric, character, and logical variables from above:  
  2a. Can you convert numeric to integer type?  
  2b. Convert numeric to logical?  
  2c. Convert numeric to character?  
  2d. Convert logical to character?  
  2e. Convert character to numeric?  

```{r}
## YOUR CODE HERE
```

##### 5. Factor type

Factor type is simply how R refers to categorical data. You will learn more about factor type once you understand vectors (see "Vector" section below).  

### Vignettes
Double question marks ?? will lead you to coding walkthroughs called "vignettes". These usually come with preloaded data and examples:  

```{r}
??psych
```

Click "PDF" next to "psych::intro" to download the walkthrough. However, you will often find that your questions are not answered by neither the help pages nor vignettes. In that case you should Google-search your question or error message along with the name of a free help website. For example, to get help making a simple histogram, I would Google search "R simple histogram stack overflow". Take some time to browse the sites listed in the "Resources" section of the README.md file. 

# Data structures

If assigning a single value to a variable is good, assigning **more than** one piece of data to a variable is better. R has many different functions to store more complex data structures as variables:  

1. `paste()` - used to concatenate (combine) text  
2. `c()` - contatenate vectors  
3. `list()` - create lists  
4. `matrix()` - construct matrices  
5. `data.frame()` - combine vectors into a tabular spreadsheet with rows and columns.  

### 1. `paste` - combine words into character vectors! 

R is very powerful for manipulating text data. Here are some basic functions for working with text. Use `paste()` to concatenate/combine character data. This will paste together separate words to larger texts.

```{r, eval=FALSE}
?paste
```
```{r}
pangram = paste("The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", paste0("dog", "."))
pangram
```

Note here that R is not a zero-indexed language - output begins at the number 1 and is designated by a number 1 in square brackets. The one and only element in this object is the sentence "The quick brown fox jumps over the lazy dog." Learn more about vectors below. 

# **Challenge 4**
1. Notice how `paste0()` is found within the `paste()` function - this is called "nesting functions". What is the purpose of the `paste0` here? 

```{r}
## YOUR CODE HERE
```

### Function arguments in action
R also has some useful functions for character data such as `grep`, `substr`, `strsplit`, and `gsub`. Use your help commands to learn more! Recall that arguments go inside of the parentheses of R functions. Unnamed arguments are things like the number 4. `split = " "` is what is called a named argument. This argument goes inside the parentheses of another function such as `strsplit`. Refer back to our `pangram` variable:

### `strsplit` - splitting strings

```{r, eval=FALSE}
?strsplit
```
```{r}
words = strsplit(pangram, split = " ")
words 
```

A list is returned. Learn more about how lists work below!

However, anything can be used as the separator. Define some slash separated text and split on the slash:
```{r}
slash_text = "This/is/slash/separated/text"
slash_text

slash_split = strsplit(slash_text, split = "/")
slash_split
```

Most functions require one or two arguments to be defined in order for it to properly run. You will find that functions are full of default, positional, and optional arguments that you can manipulate.  

### `substr` - subsetting strings

`substr` lets you extract text from certain character positions in character data. Refer back to `pangram` - extract just the 4th through the 11th characters.

```{r, eval=FALSE}
?substr
```
```{r}
sub_text = substr(pangram, start = 4, stop = 11)
sub_text
```

" quick b" is returned. 

# **Challenge 5**
1. `substr` can also be used to reassign parts of text. Fill in the question marks below so that that fox jumps over the cow instead of the dog. 

```{r eval = F}
## YOUR CODE HERE
substr(pangram, start = ?, stop = ?) = ?
```

How did you do? Counting out all the character positions (indexes or indices) is a pain! Thanksfully there are functions we can use to search for words. 

### `gsub` - string substitution

You can also substitute with `gsub()`. Let's say we want to substitute cow for frog in `pangram`. We could type:
```{r}
pangram
frog = gsub("cow", "frog", pangram)
frog
```

### `grep` - pattern matching and replacement

```{r, eval=FALSE}
?grep
```
Learn more about the `grep` function below! Also see the resources section in the README.md file to learn about regular expressions. 

### 2. Vector

A **VECTOR** is an ordered group of the same kind of data. "Ordered" means that position matters. Vectors are one-dimensional and homogenous, and are thus referred to by their type (e.g., character vector, numeric vector, logical vector). It does not matter what type of data are in the vector, as long as it is all the same! 

Create a numeric vector by combining/concatenating elements with `c()`  
```{r, eval=FALSE}
?c
```
```{r}
numeric_vector = c(234, 31343, 78, 0.23, 0.0000002)
numeric_vector

# turn off scientific notation
options(scipen = 999)
numeric_vector
```
This numeric vector contains five elements.  

##### 2.1 Indexing vectors

You can refer to the position of a value within a data structure by calling its "index". Use square brackets to do so (more on this in the subsetting section of Part 2). To see what value occupies the third position of the object `numeric_vector`, you could type: 

```{r}
numeric_vector[3]
```

##### 2.2 Add items to vectors

You can also add items to a vector by adding them as additional arguments and separated by commas (as long as they are of the same type!)
```{r}
numeric_vector2 = c(numeric_vector, c(0.1, 0.2, 0.3))
numeric_vector2
```

# **Challenge 6**
1. Build a vector of logical data type and save it in a variable named `logical_vector`  
2. Can you divide `numeric_vector` by `numeric_vector2`? Why or why not?  
2. Can you multiply `numeric_vector` by `logical_vector`? Why or why not?  

##### 2.3 `seq` generating (pseudo)random numbers  

You might need to create vectors that are sequences of numbers. You can do this via `seq`. Define the from, to, and by arguments: 

```{r, eval=FALSE}
sequence = seq(from = 0, to = 8, by = 1)
sequence
```

##### 2.4 Sequence where `by = 1` (`:`)

R also gives you a shorthand operator for creating sequences in whole number increments of 1. This is the colon symbol `:`
```{r}
0:8

sequence_object = c(28:36)
sequence_object 

0:length(numeric_vector)
```

### `set.seed`
You can also generate pseudo-random groups of numbers. Use `set.seed()` to ensure that we get the same pseudo-random draws from the parent universe, even on different computers! 

Let's generate five different vectors of length 10 for numeric, integer, logical, character, and factor data types. 

```{r eval = F}
?set.seed

# Sample numbers from the uniform distribution
?runif

# Sample numbers from the normal distribution. 
?rnorm

# Sample numbers, logical values, character strings, etc.
?sample
```

Set the seed, and then choose our values:
```{r}
set.seed(1)

uniform = runif(n = 10, min = 10000, max = 10000000000) # 10 random samples from uniform distribution between the numbers ten-thousand and ten billion
uniform

normal = rnorm(10, 0, 1) # 20 random samples from the normal distribution with a mean of 0 and standard deviation of 1
normal

integer = sample(1990:2010, 10, replace = FALSE) # 20 random samples from between the numbers 5 and 10. Note that `replace=TRUE` signifies that it is OK to reuse numbers already selected.
integer

character = sample(c("Canada", "USA", "Mexico"), 10, replace = TRUE) # 20 random samples of character data
character

logical = sample(c(TRUE, FALSE), 10, replace = TRUE) # 20 random samples of logical data
logical
```

### List
A **LIST** is an ordered group of data that are not of the same type. Lists are heterogenous. Instead of using `c()` like in vector creation, use `list()` to create a list:
```{r, eval=FALSE}
?list

list1 = list(TRUE, "one", 1) # include three kinds of data: logical, character, and integer
list1
class(list1)
```

Lists are simple containers and are not additive or multiplicative like vectors and matrices are:
```{r, eval=FALSE}
list1 * list(FALSE, "zero", 0) # Error
```

### Matrix  
**MATRICES** are homogenous like vectors. They are tables comprised of data all of the same type. Matrices are organized into rows and columns. 

Use `matrix()` to create a matrix
```{r, eval=FALSE}
?matrix
```

We can also specify how we want the matrix to be organized using the `nrow` and `ncol` arguments:

```{r}
matrix1 = matrix(1:12, nrow = 4, ncol = 3) # this makes a 4 x 3 matrix
matrix1
class(matrix1)
```

We can also coerce a vector to a matrix, because a vector is comprised of homogenous data of the same kind, just like a matrix is:

```{r}
# Create a numeric vector from 1 to 20
vec1 = c(1:20)
vec1
class(vec1)

# Coerce this vector to a matrix with 10 rows and 2 columns:
matrix2 = matrix(vec1, ncol = 2)
matrix2
class(matrix2)
```

### Data frame  
_**It is worth emphasizing the importance of data frames in R!**_ Inside R, a **DATA FRAME** is a list of equal-length vectors. These vectors can be of different types. Data frames are thus heterogenous like lists.  

This is simply a spreadsheet!  

Let's create a dataframe called `gdp` using the vectors we already created:
```{r, eval=FALSE}
uniform
normal
integer
character
logical
```

We do this using `data.frame()`
```{r, eval=FALSE}
?data.frame
```
```{r}
gdp = data.frame(uniform, normal, integer, character, logical, stringsAsFactors = FALSE)
# NOTE: `stringsAsFactors=FALSE` means that R will NOT try to interpret character data as factor type. More on this below. 
```

Take a peek at the `gdp` data frame to see what it looks like:
```{r}
gdp
```

We can change the names of the columns by passing into it a vector with our desired names
```{r}
# Create a vector called `new_df_names` with the new column names:
new_col_names = c("gdpPercap", "growth_rate", "Year", "Country", "Happy")

# Pass this vector into `colnames()`
colnames(gdp) = new_col_names
gdp
```

We can check the structure of our data frame via `str()`
```{r, eval=FALSE}
?str
str(gdp)
```
Here, we can see that a data frame is just a list of equal-length vectors! For readability purposes, `str()` displays columns from top to bottom, while the data are displayed left to right. 

##### Learning about your data frame  
```{r}
# View the dimensions (nrow x ncol) of the data frame:
dim(gdp) 

# View column names:
colnames(gdp)

# View row names (we did not change these, so they default to character type)
rownames(gdp)
class(rownames(gdp))
```

##### Change column order
You can change the order of the columns by specifying their new order using `c()` within what is called "bracket notation" `[ , ]`. 

> This will be covered with the rest of subsetting in Part 2. 

```{r}
gdp = gdp[,c("Country", "Year", "gdpPercap", "growth_rate", "Happy")]
gdp
```

##### Sorting data

You can also sort data by increasing/decreasing alphanumeric order. Sort by Country and then Year by typing: 

```{r}
?order
```
```{r}
gdp_sorted <- gdp[order(gdp$Country, gdp$Year),]
gdp_sorted
```

##### Factor data type  

Factor data are categorical types used to make comparisons between other data. Factors group the data by their "levels" (the different categorical groups within a factor).  

For example, in our `gdp` dataframe, we can coerce "Country" from character to factor type. Canada, Mexico, and USA are the factor levels. If we might want to compare gdpPercap and growth_rate between these three countries, we set the character "Country" vector to factor data type. We can do so with `factor()`.  

The dollar sign operator `$` is used to call a single vector from a data frame. This will be discussed more in Part 2 along with the rest of subsetting.
```{r}
str(gdp) # "Country" is character type. 
gdp$Country = factor(gdp$Country) # Convert "Country" to factor type. 
str(gdp) # "Country" is now factor type!
```

Notice that R stores factors internally as integers and uses the character strings as labels. Also notice that by default R orders factors alphabetically and returns them when we call the "Country" vector.

```{r}
gdp$Country
levels(gdp$Country)
```

##### Changing factor "levels"

If we want to change how R stores the factor levels, we can specify them by using the `levels()` argument. For example:

```{r}
gdp$Country  # Levels: Canada, Mexico, USA (default alphabetical sort)

# What if we want to change the factor level sort to Levels: Mexico, USA, Canada?

gdp$Country = factor(gdp$Country, levels = c("Mexico", "USA", "Canada"))
gdp$Country # The level order has changed. 
```

> NOTE: we will load an actual subset of the `gdp` data frame from file at the beginning of Part 2, so do not worry if your dataframe is not identical to your neghbor's! 

# Saving your work (`write.csv`)  
It is always good to save your work. Saving a dataframe as a .CSV file is a convenient way to store it for future use. **Anything saved will be placed into your working directory by default!** 

See where your data frame is saved by typing: 
```{r}
getwd()
```

> NOTE: we will begin Part 2 with a discussion about how to check and set the [working directory](https://en.wikipedia.org/wiki/Working_directory). The easiest way is to click "Session" --> "Set working directory" --> "Choose directory". Do this if you want to change your working directory location. Run `getwd()` again - did the file path change?  

The syntax looks like this:
`write.csv(object_name, file = "nameOfFile.csv", row.names = TRUE)`

# **Challenge 7**
1. Save the "gdp" data frame as a .csv file named "gdp.csv". 

```{r}
## YOUR CODE HERE
```

Check your working directory to see if it worked!  

> We will talk about saving plots as .PDF and .TIFF file types in Part 3!  

# **Challenge 8** Homework (optional)
swirl is a package that helps you learn R by using R. Visit the [swirl](http://swirlstats.com/) homepage to learn more
```{r, eval=FALSE}
library(swirl)
swirl()
# follow the instructions until you can select number 1 "R Programming: The basics of programming in R"
```

> NOTE: type `bye()` to exist swirl. 

Acknowledgements
- [Wickham H. 2014. Advanced R](http://adv-r.had.co.nz/)  
- [Lander J. 2013. R for everyone: Advanced analytics and graphics](http://www.jaredlander.com/r-for-everyone/)  
- [Matloff N. 2011. The art of R programming: A tour of statistical software design](https://www.nostarch.com/artofr.htm)  
- [Brunsdon C, Comber L. 2015. An Introduction to R for Spatial Analysis and Mapping](https://us.sagepub.com/en-us/nam/an-introduction-to-r-for-spatial-analysis-and-mapping/book241031)
- Contributions by Evan Muzzall, Rochelle Terman, Dillon Niederhut, Sam Abdel-Ghaffar