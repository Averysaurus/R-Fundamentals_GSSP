# subset a dataframe named Dogs that contains only dogs from the animals data frame
cats <- animals[animals$Type == "Cat",]
dogs <- animals[animals$Type == "Dog",]
cats
dogs
# is there a statistically real difference between cat and dog weight?
t.test(cats$Weight, dogs$weight)
# is there a statistically real difference between cat and dog weight?
t.test(cats$Weight, dogs$Weight)
# is there a statistically real difference between cat and dog weight?
t.test(cats$Weight, dogs$Weight,
alternative = "less")
# is there a statistically real difference between cat and dog weight?
t.test(cats$Weight, dogs$Weight,
alternative = "greater")
# what about mean comparisons between three groups?
?aov
?anova
aov1 <- aov(Weight ~ Type, data = animals)
aov1 <- aov(animals$Weight ~ animals$Type)
summary(aov1)
# Tukey HSD is great post hoc test to aov
?TukeyHSD
TukeyHSD(aov1)
0.05/3
0.05/3
TukeyHSD(aov1)
# Pearson correlation
?cor.test
cor.test(animals$Weight, animals$Height)
# simple linear regression
# X = independent, input, predictor variable
# Y = dependent, target, response, outcome variable
# syntax looks like this: Y ~ X
?lm
lm1 <- lm(Weight ~ Height, data = animals)
summary(lm1)
# load the mtcars dataset
data(mtcars)
str(mtcars)
?mtcars
View(mtcars)
View(mtcars)
# investigate the mtcars dataset
# create descriptive statistics for mpg and cyl variables
summary(mtcars$mpg)
describe(mtcars$mpg)
str(mtcars)
table(mpg)
table(mtcars$mpg)
table(mtcars)
table(mtcars$cyl)
ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width)
)
summary(lm1)
ggplot(mtcars, aes(mpg, cyl))
ggplot(mtcars, aes(mpg, cyl)) +
geom_point()
ggplot(mtcars, aes(mpg, cyl, color = cyl)) +
geom_point()
ggplot(mtcars, aes(mpg, cyl, color = as.factor(cyl))) +
geom_point()
?str
?mtcars
# investigate the mtcars dataset
# create descriptive statistics for mpg and cyl variables
summary(mtcars$mpg)
describe(mtcars$mpg)
table(mtcars$mpg)
table(mtcars$cyl)
# plot this relationship somehow
ggplot(mtcars, aes(mtcars$cyl, mtcars$mpg))
# plot this relationship somehow
ggplot(mtcars, aes(mtcars$cyl, mtcars$mpg)) +
geom_point()
# plot this relationship somehow
ggplot(mtcars, aes(mtcars$cyl, mtcars$mpg)) +
geom_boxplot()
# plot this relationship somehow
ggplot(mtcars, aes(x = mtcars$cyl, y = mtcars$mpg)) +
geom_boxplot()
# plot this relationship somehow
ggplot(mtcars, aes(x = mtcars$cyl, y = mtcars$mpg, group = cyl)) +
geom_boxplot()
# plot this relationship somehow
ggplot(mtcars, aes(x = mtcars$cyl, y = mtcars$mpg, group = as.factor(cyl))) +
geom_boxplot()
# plot this relationship somehow
ggplot(mtcars, aes(x = as.factor(mtcars$cyl), y = mtcars$mpg, group = as.factor(cyl))) +
geom_boxplot()
# are mpg and cyl correlated?
cor.test(mtcars$mpg, mtcats$cyl)
# are mpg and cyl correlated?
cor.test(mtcars$mpg, mtcars$cyl)
aov_cars <- aov(mtcars$mpg ~ as.factor(mtcars$cyl))
summary(aov_cars)
str(mtcars)
summary(aov_cars)
TukeyHSD(aov_cars)
# can cyl be used to predict mpg?
lm_cars <- lm(mtcars$mpg ~ mtcars$cyl)
summary(lm_cars)
# can cyl be used to predict mpg?
lm_cars <- lm(mtcars$mpg ~ as.factor(mtcars$cyl))
summary(lm_cars)
# can cyl be used to predict mpg?
lm_cars <- lm(mtcars$mpg ~ as.factor(mtcars$cyl))
summary(lm_cars)
# I can comment my code inside chunks with hashtags
# this is 2+2
2+2
3*3
# I can comment my code inside chunks with hashtags
# this is 2+2
2+2
3*3
data(iris)
library(ggplot2)
ggplot(iris, aes(Petal.Width, Petal.Length)) +
geom_point()
data(iris)
library(ggplot2)
ggplot(iris, aes(Petal.Width, Petal.Length, color = Species)) +
geom_point()
nrow
nrow
mean
# Note that doing this manually or via nrow gives the same result:
data(iris)
nrow
dim(iris)[1L]
nrow(iris)
dim(iris)[1L] == nrow(iris)
mean
(1+2+3)/3
mean(c(1,2,3))
nrow
mean
?reserved
for(x in 1:10){
print(x)
}
# ?reserved
vec <- c(rep(NA, 10))
vec
vec
for(i in 1:10){
vec[i] <- 2^(i)
}
vec
class(vec)
for(i in 1:5){
vec[i] <- 3^i
}
vec
#This has changed only the first five entries of `vec`
animal.names <- c("Cat", "Dog", "Pig", "Elephant", "Giraffe")
animal.names
length(animal.names)
animals.length <- rep(NA, length(animal.names))
animals.length
animal.names
names(animals.length) <- animal.names
animals.length  #See how we are building this from scratch?
names(animals.length) <- animal.names
animals.length  #See how we are building this from scratch?
?nchar
animal.names
for(i in animal.names){
animals.length[i] <- nchar(i)
}
animals.length
for(i in animal.names){
animals.names[i] <- nchar(i)
}
animals.length
for(i in animal.names){
animal.names[i] <- nchar(i)
}
animals.length
for(i in animal.names){
animal.names[i] <- nchar(i)
}
animal.names
for(i in animal.names){
animals.length[i] <- nchar(i)
}
animals.length
animal.names <- c("Cat", "Dog", "Pig", "Elephant", "Giraffe")
animal.names
animals.length <- rep(NA, length(animal.names))
animals.length
names(animals.length) <- animal.names
animals.length  #See how we are building this from scratch?
for(i in animal.names){
animals.length[i] <- nchar(i)
}
animals.length
for(i in 1:100){
print(i)
}
for(i in 1:10){
print(i)
}
for(x in 1:10){
if(x < 5)
print(x)
}
my_nums <- 40:70
my_nums
my_nums <- 40:70
for(i in 1:length(my_nums)){
print(my_nums[i])
if(my_nums[i] == 50) break
}
# Numbers up to and including 50 are printed!
if(my_nums == 50) break
for(i in my_nums){
print(my_nums)
if(my_nums == 50) break
}
for(i in my_nums){
print(my_nums)
if(my_nums[i] == 50) break
}
# Numbers up to and including 50 are printed!
for(i in 1:length(my_nums)){
print(my_nums)
if(my_nums == 50) break
}
my_nums
my_nums[15] <- as.numeric(NA)
my_nums
for(i in 1:length(my_nums)){
print(my_nums[i])
stopifnot(!is.na(my_nums[i]))
}
# hint: ! is "logical not"
paste("paste", "is sort of like", "c", "but for", "words!")
for (year in 2010:2015){
print(paste("The year is", year))
}
# your code here
ggplot(iris, aes(x = Petal.Length
7654
ggplot(iris, aes(x = Petal.Length
, y=Petal.Width))
ggplot(iris, aes(x = Petal.Length
x <- 1
x <- 1
if(x > 7){
print(x)
}else{   #`else` should not start its own line. Always let it be preceded by a closing brace on the same line.
print("Error: number not big enough")
}
x <- 10
if(x > 7){
print(x)
}else{   #`else` should not start its own line. Always let it be preceded by a closing brace on the same line.
print("Error: number not big enough")
}
x <- 1:10
x <- 1:10
for (i in 1:length(x)){
if(i > 7){
print(i)
}else{
print("Error: number not big enough")
}
}
#Super cool! :)
x <- 1:10
for (i in 1:length(x)){
if(i >= 7){
print(i)
}else{
print("Error: number not big enough")
}
}
#Super cool! :)
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
sample(c("cat", "dog"), 10, replace=TRUE)
sample(c("cat", "dog"), 10, replace=TRUE)
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(14908576)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(14908576)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
set.seed(1)
animal <- sample(c("cat", "dog"), 10, replace=TRUE)
animal
animal_int <- ifelse(animal == "cat", 1, 0)
animal_int
animal_char <- ifelse(animal_int == 1, "meow!?", "WOOF")
animal_char
animal_bool <- ifelse(animal_char == "meow!?", TRUE, FALSE)
animal_bool
animal2 <- ifelse(animal_bool == TRUE, "cat", "dog")
animal2
animal == animal2 # or
sum(animal != animal2)
test_function <- function(x){
x ^ 2
}
class(test_function)        # Returns the class of `test_function`
formals(test_function)      # Shows the defined arguments
body(test_function)
environment(test_function)
test_function               # Shows your function as you have written it
test_function(2)
test_function(1:10)
test_function
test_function(1:10)
f <- function(x, y=2){
(x + y) / y
}
f(x=5)
f(4, 4) # here, we do not need to specify `x` and `y` because R knows that the second argument is "y"
f(4, y=4)
#does f(y=4, 4) work? Yes, but it is not recommended.
f(y=4, 4)
ls()
f <- function(x, y=2){
z <- 5
(x + y) / z
}
ls()
f(4, 4)
z <- 5 # define z outside of the function environment
ls()
f <- function(x, y=2){
(x + y) / z
}
f(4, 4)
function_multi = function(a, b, c, d){
print(a)
print(a + b)
print(a + b * c)
print(a + b * c / d)
}
function_multi(a = 1, b = 2, c = 3, d = 4)
function_squared = function(x){
for(i in 1:x){
y <- i ^ 2
print(y)
}
}
function_squared(5)
function_multi = function(a, b, c, d){
print(a)
print(a + b)
print(a + b * c)
print(a + b * c / d)
}
function_multi(a = 1, b = 2, c = 3, d = 4)
function_squared = function(x){
for(i in 1:x){
y <- i ^ 2
print(y)
}
}
function_squared(5)
cylinders = data.frame(height = c(3,4,5,6,7),
radius = c(1,3,2,1,5))
cylinders
cylinders_function = function(height, radius){
volume = pi * radius ^ 2 * height
print(volume)
}
cylinders$height
cylinders_function(height = cylinders$height, radius = cylinders$radius)
PEMDAS!
FOIL
sample(1:6, 1)
sample(1:6, 1)
sample(1:6, 1)
sample(1:6, 1)
sample(1:6, 1)
sample(1:6, 100, replace=TRUE)
# We can also use the sample function to simulate 100 die rolls...
sample(1:6, 100, replace=TRUE)
for (i in 1:iter){
rolls <- sample(1:6, nr_rolls, replace=TRUE)
#print(rolls)
print(mean(rolls))
}
iter <- 200
nr_rolls <- 100
for (i in 1:iter){
rolls <- sample(1:6, nr_rolls, replace=TRUE)
#print(rolls)
print(mean(rolls))
}
iter <- 200
nr_rolls <- 100
for (i in 1:iter){
rolls <- sample(1:6, nr_rolls, replace=TRUE)
print(rolls)
print(mean(rolls))
}
for (i in 1:iter){
rolls <- sample(1:6, nr_rolls, replace=TRUE)
#print(rolls)
print(mean(rolls))
}
die_roll_mean <- function(nr_rolls){
rolls <- sample(1:6, nr_rolls, replace=TRUE)
mean(rolls)
}
die_roll_mean(nr_rolls = 100)
# 100 roll mean
reps <- replicate(200, die_roll_mean(nr_rolls = 100))
reps
# 5 roll mean
reps <- replicate(200, die_roll_mean(nr_rolls = 5))
reps
hist(reps)
hist(reps, col="grey")
abline(v=mean(reps), col="blue", lwd=6)
hist(reps)
hist(reps, col="grey")
abline(v=mean(reps), col="blue", lwd=6)
my_hist <- function(sims){
hist(sims, col="grey", xlab="Mean of n die rolls", main="")
abline(v=mean(sims), col="blue", lwd=6)
}
my_hist(sims=reps)
paste("Paste", "will include", "blank spaces")
paste0("Paste", "will include", "blank spaces")
paste0("I", "am", "HANGRAY")
paste("I", "am", "HANGRAY")
my_hist <- function(sims, n){
hist(sims, col="grey",  xlab="Mean of n die rolls",
main=paste0("n=",n), xlim=c(2,5))
abline(v=mean(sims), col="blue", lwd=2)
}
my_hist(sims=reps, n=5)
nr_die_rolls <- c(10, 25, 50, 100, 200, 500)
par(mfrow=c(2,3))
for (i in 1:length(nr_die_rolls)){
reps <- replicate(1000, die_roll_mean(nr_rolls = nr_die_rolls[i]))
my_hist(sims=reps, n=nr_die_rolls[i])
}
par(mfrow=c(2,3))
for (i in 1:length(nr_die_rolls)){
reps <- replicate(1000, die_roll_mean(nr_rolls = nr_die_rolls[i]))
my_hist(sims=reps, n=nr_die_rolls[i])
}
set.seed(94705)
birthdays <- sample(1:365, 25, replace=TRUE)
birthdays
unique(birthdays)
length(unique(birthdays))
set.seed(94705)
birthday_function <- function(people=25){
# we populate the room
birthdays <- sample(1:365, people, replace=TRUE)
# get the unique number of bdays
unique_bdays <- length(unique(birthdays))
# and return a 1 if at least one bday is repeated.
as.numeric(unique_bdays!=people)
}
birthday_function(people=25)
set.seed(94705)
many_sims <- replicate(1000, birthday_function(people=25))
many_sims
mean(many_sims)
people <- 2:100
sims <- matrix(NA, length(people), 2)
sims
sims <- matrix(NA, nrow = length(people), ncol = 2)
sims
length(people)
2:100
for(i in 1:length(people)){
many_sims <- replicate(5000, birthday_function(people=people[i]))
sims[i,] <- c(people[i], mean(many_sims))
}
sims
par(mfrow=c(1,1))
plot(x = sims[,1], y = sims[,2],
pch=16, col="blue",
xlab="Nr of People",
ylab="Probability of at Least One Match")
par(mfrow=c(2,3))
for (i in 1:length(nr_die_rolls)){
reps <- replicate(1000, die_roll_mean(nr_rolls = nr_die_rolls[i]))
my_hist(sims=reps, n=nr_die_rolls[i])
}
dim(iris)[1]
dim(iris)
dim(iris)[1]
dim(iris)[1L]
